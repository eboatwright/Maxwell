thoughts on NNUE:
	I've wanted to learn how to write neural net for a long time, so I want to implement NNUE eventually.
	But what I'm not going to do is just find a SF NNUE library and stick it in there because that's lame

	Update 1:
	I've learned how to write neural networks, and trained one to evaluate Tic-Tac-Toe positions!
	So for either v3.2 or v3.3 I'm gonna work on writing my own version of NNUE from scratch

	Update 2:
	I've gotten a simple NNUE architecture in place: 768 -> 256 -> 1
	And it's pretty fast! Weiawaga was a big reference, but I ultimately ended up re-writing it multiple times

	Update 3:
	I found evaluation data to train the network!
	I'm not sure how to have the NNUE self-train, so I'll start with this
	https://database.lichess.org/#evals

	Update 4:
	I've got all the data I need parsed from the Lichess DB, and some basic training code
	But it's atrociously slow, as I don't have back-propagation

	Also thanks to the dev of Leorik for explaining how self-play works!

	I'm gonna start with the Lichess data just as a test run,
	then once I fix it up I'll train a fully self-play network :^D

figure out some sort of multithreading:
	to implement pondering I think I'll have to add multithreading

	maybe one thread that waits for UCI commands like "stop"
	and all the rest of the threads search

	https://www.chessprogramming.org/Lazy_SMP

transposition table:
	buckets
	aging
	make it multithreading safe
	prefetching

try removing all the attacked squares bitboards stuff, and just make a function that detects whether one square is attacked?
try giving a small boost in evaluation for the current side to move
try lower pawn evaluation values
experiment with more than 2 killer moves per ply
calculate my own magic numbers; currently "borrowing" Sebastian Lague's ^^
check out pin detection to speed up check detection
try writing a struct that sorts moves incrementally
	I tried this a couple times, but haven't got it faster than my current solution
re-implement PV table with a different approach; I don't like the 2d array

History reductions / pruning
https://www.chessprogramming.org/Internal_Iterative_Deepening
https://www.chessprogramming.org/Static_Exchange_Evaluation
https://www.chessprogramming.org/Futility_Pruning#MoveCountBasedPruning (Late move pruning)
https://www.chessprogramming.org/History_Leaf_Pruning
https://www.chessprogramming.org/ProbCut
https://www.chessprogramming.org/Razoring#Strelka
https://www.chessprogramming.org/Texel's_Tuning_Method

Some random resources I found: (Not using them right now but they could be useful)
https://analog-hors.github.io/site/magic-bitboards/
https://mediocrechess.blogspot.com/2006/12/guide-attacked-squares.html